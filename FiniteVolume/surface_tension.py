''' This is a droplet falling in a box with surface tension modeled using the Navier Stokes equations. FTCS discretization is used. Density is advectedby a front tracking scheme.'''import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import cmfrom IPython import display#============ DOMAIN SIZE AND PHYSICAL VARIABLES ===============#Lx = 1.Ly = 1.gx = 0.gy = -100.rho1 = 1.rho2 = 2.rro = rho1m1 = 0.01m2 = 0.05sigma = 10unorth = 0.usouth = 0.vwest = 0.veast = 0.rad = 0.15    # Droplet size and locationxc = 0.5yc = 0.7nx = 32ny = 32dt = 0.00125nstep = 200maxit = 200maxError = 1e-3beta = 1.2# Initialize arraysu=np.zeros((nx+1,ny+2)); v=np.zeros((nx+2,ny+1)); p=np.zeros((nx+2,ny+2))ut=np.zeros((nx+1,ny+2)); vt=np.zeros((nx+2,ny+1)); tmp1=np.zeros((nx+2,ny+2))uu=np.zeros((nx+1,ny+1)); vv=np.zeros((nx+1,ny+1)); tmp2=np.zeros((nx+2,ny+2))Ax = np.zeros_like(u)Dx = np.zeros_like(u)Ay = np.zeros_like(v)Dy = np.zeros_like(v)# Set the griddx = Lx/nxdy = Ly/nyx = np.linspace(-0.5*dx, nx*dx+0.5*dx, nx+2)y = np.linspace(-0.5*dy, ny*dy+0.5*dy, ny+2)# Set density and viscosity in domain and dropr = np.ones((nx+2,ny+2))*rho1m = np.ones((nx+2,ny+2))*m1rn = np.zeros((nx+2,ny+2))    # second ordermn = np.zeros((nx+2,ny+2))    # second orderfor i in range(1, nx+1):    for j in range(1, ny+1):        if ((x[i]-xc)**2+(y[j]-yc)**2) < rad**2:            r[i,j] = rho2            m[i,j] = m2#============ SET UP THE FRONT ===============#nf = 100xf = np.zeros(nf+2)yf = np.zeros(nf+2)tx = np.zeros(nf+2)ty = np.zeros(nf+2)xfn = np.zeros(nf+2)yfx = np.zeros(nf+2)for i in range(nf+1):    xf[i] = xc - rad*np.sin(2.*np.pi*i/nf)    yf[i] = yc + rad*np.cos(2.*np.pi*i/nf)    #============ START TIME LOOP ===============#for step in range(nstep):    un = np.copy(u)    vn = np.copy(v)    rn = np.copy(r)    mn = np.copy(m)    xfn = np.copy(xf)    yfn = np.copy(yf)        #------- BEGIN SECOND ORDER (PREDICTOR-CORRECTOR) --------#    for substep in range(2):        #============ FIND SURFACE TENSION ===============#          fx = np.zeros((nx+2,ny+2))        fy = np.zeros((nx+2,ny+2))        for i in range(nf+1):            ds = np.sqrt((xf[i+1]-xf[i])**2 + (yf[i+1]-yf[i])**2)            tx[i] = (xf[i+1]-xf[i])/ds    # tangent vector x-component            ty[i] = (yf[i+1]-yf[i])/ds    # tangent vector y-component                tx[nf+1] = tx[1]        ty[nf+1] = ty[1]                # Distribute to the fixed grid        for i in range(1,nf+1):            nfx = sigma*(tx[i]-tx[i-1])            nfy = sigma*(ty[i]-ty[i-1])                        ip =int(np.floor(xf[i]/dx))            jp = int(np.floor(yf[i]/dy+0.5))            ax = xf[i]/dx - ip            ay = yf[i]/dy + 0.5 - jp            fx[ip,jp] += (1-ax)*(1-ay)*nfx/(dx*dy)            fx[ip+1,jp] += ax*(1-ay)*nfx/(dx*dy)            fx[ip,jp+1] += ay*(1-ax)*nfx/(dx*dy)            fx[ip+1,jp+1] += ax*ay*nfx/(dx*dy)                        ip =int(np.floor(xf[i]/dx + 0.5))            jp = int(np.floor(yf[i]/dy))            ax = xf[i]/dx + 0.5 - ip            ay = yf[i]/dy - jp            fy[ip,jp] += (1-ax)*(1-ay)*nfy/(dx*dy)            fy[ip+1,jp] += ax*(1-ay)*nfy/(dx*dy)            fy[ip,jp+1] += ay*(1-ax)*nfy/(dx*dy)            fy[ip+1,jp+1] += ax*ay*nfy/(dx*dy)                    # Tangential velocity at boundaries        u[:,0] = 2*usouth - u[:,1]        u[:,-1] = 2*unorth - u[:,-2]        v[0,:] = 2*vwest - v[1,:]        v[-1,:] = 2*veast - v[-2,:]                #============ TEMPORARY U-VELOCITY ADVECTION ===============#         # for i in range(1, nx):        #     for j in range(1, ny+1):        #         ut[i,j] = u[i,j] - dt*(0.25/dx*((u[i+1,j]+u[i,j])**2 - (u[i,j]+u[i-1,j])**2) +        #                   0.25/dy*((u[i,j+1]+u[i,j])*(v[i+1,j]+v[i,j]) -        #                             (u[i,j]+u[i,j-1])*(v[i+1,j-1]+v[i,j-1])) +        #                   fx[i,j]/(0.5*(r[i+1,j]+r[i,j])) +        #                   (1-rro/(0.5*(r[i+1,j]+r[i,j])))*gx)                for i in range (1,nx):                for j in range (1,ny+1):                    ut[i,j]=u[i,j]+dt*(-0.25*(((u[i+1,j]+u[i,j])**2-(u[i,j]+\                            u[i-1,j])**2)/dx+((u[i,j+1]+u[i,j])*(v[i+1,j]+\                            v[i,j])-(u[i,j]+u[i,j-1])*(v[i+1,j-1]+v[i,j-1]))/dy)+\                            fx[i,j]/(0.5*(r[i+1,j]+r[i,j]))+ (1.0 -rho1/(0.5*(r[i+1,j]+r[i,j])))*gx)                                        #============ TEMPORARY V-VELOCITY ADVECTION ===============#         # for i in range(1, nx+1):        #     for j in range(1, nx):        #         vt[i,j] = v[i,j] - dt*(0.25/dy*((v[i,j+1]+v[i,j])**2 - (v[i,j]+v[i,j-1])**2) +        #                   0.25/dx*((u[i,j]+u[i,j+1])*(v[i,j]+v[i+1,j]) -        #                             (u[i-1,j+1]+u[i-1,j])*(v[i,j]+v[i-1,j])) +        #                   fy[i,j]/(0.5*(r[i,j+1]+r[i,j])) +        #                   (1-rro/(0.5*(r[i,j+1]+r[i,j])))*gy)                        for i in range (1,nx+1):                for j in range (1,ny):                     vt[i,j]=v[i,j]+dt*(-0.25*(((u[i,j+1]+u[i,j])*(v[i+1,j]+\                            v[i,j])-(u[i-1,j+1]+u[i-1,j])*(v[i,j]+v[i-1,j]))/dx+\                            ((v[i,j+1]+v[i,j])**2-(v[i,j]+v[i,j-1])**2)/dy)+\                            fy[i,j]/(0.5*(r[i,j+1]+r[i,j]))+ (1.0 -rho1/(0.5*(r[i,j+1]+r[i,j])) )*gy)                        #============ TEMPORARY U-VELOCITY DIFFUSION ===============#        # for i in range(1,nx):        #     for j in range(1,ny+1):        #         ut[i,j] += ((2*dt/dx**2*(mu[i+1,j]*(u[i+1,j]-u[i,j]) - mu[i,j]*(u[i,j]-u[i-1,j])) +        #                     dt/dy*(0.25*(mu[i+1,j]+mu[i+1,j+1]+mu[i,j]+mu[i,j+1]) *        #                               ((u[i,j+1]-u[i,j])/dy + (v[i+1,j]-v[i,j])/dx) -        #                           0.25*(mu[i,j]+mu[i,j-1]+mu[i+1,j]+mu[i+1,j-1]) *         #                                 ((u[i,j]-u[i,j-1])/dy + (v[i+1,j-1]-v[i,j-1])/dx))) /        #                     (0.5*(r[i+1,j]+r[i,j])))                        for i in range (1,nx):                for j in range (1,ny+1):                    ut[i,j]=ut[i,j]+dt*((1./dx)*2.*(m[i+1,j]*(1./dx)*(u[i+1,j]-u[i,j])-\                            m[i,j] *(1./dx)*(u[i,j]-u[i-1,j]))+\                            (1./dy)*(0.25*(m[i,j]+m[i+1,j]+m[i+1,j+1]+m[i,j+1])*((1./dy)*(u[i,j+1]-u[i,j])+\                            (1./dx)*(v[i+1,j]-v[i,j]))-0.25*(m[i,j]+m[i+1,j]+m[i+1,j-1]+m[i,j-1])*((1./dy)*(u[i,j]-u[i,j-1])+\                            (1./dx)*(v[i+1,j-1]- v[i,j-1]))))/(0.5*(r[i+1,j]+r[i,j]))                #============ TEMPORARY V-VELOCITY DIFFUSION ===============#        # for i in range(1,nx+1):        #     for j in range(1,nx):        #         vt[i,j] += dt*((1/dx*(0.25*(mu[i+1,j]+mu[i+1,j+1]+mu[i,j]+mu[i,j+1]) *         #                                 ((u[i,j+1]-u[i,j])/dy + (v[i+1,j]-v[i,j])/dx) -        #                             0.25*(mu[i,j]+mu[i,j+1]+mu[i-1,j]+mu[i-1,j+1]) *         #                                 ((u[i-1,j+1]-u[i-1,j])/dy + (v[i,j]-v[i-1,j])/dx)) +        #                       2/dy*(mu[i,j+1]*(v[i,j+1]-v[i,j])/dy - mu[i,j]*(v[i,j]-v[i,j-1])/dy)) /        #                     (0.5*(r[i,j+1]+r[i,j])))                        for i in range (1,nx+1):                for j in range (1,ny):                    vt[i,j]=vt[i,j]+dt*((1./dx)*( 0.25*(m[i,j]+m[i+1,j]+m[i+1,j+1]+\                            m[i,j+1])*((1./dy)*(u[i,j+1]-u[i,j])+(1./dx)*(v[i+1,j]-v[i,j]))-\                            0.25*(m[i,j]+m[i,j+1]+m[i-1,j+1]+m[i-1,j])*((1./dy)*(u[i-1,j+1]-u[i-1,j])+\                            (1./dx)*(v[i,j]- v[i-1,j])))+(1./dy)*2.*(m[i,j+1]*(1./dy)*(v[i,j+1]-v[i,j])-\                            m[i,j] *(1./dy)*(v[i,j]-v[i,j-1])))/(0.5*(r[i,j+1]+r[i,j]))                        #============ COMPUTE PRESSURE TERM ===============#        # Source term for pressure equation        rt = np.copy(r)        lrg = 1000.        rt[0,:] = lrg        rt[-1,:] = lrg        rt[:,0] = lrg        rt[:,-1] = lrg            # Assemble and compute pressure        for i in range(1,nx+1):            for j in range(1,ny+1):                tmp1[i,j] = 1/(2*dt)*((ut[i,j]-ut[i-1,j])/dx + (vt[i,j]-vt[i,j-1])/dy)                tmp2[i,j] = 1/((1/dx**2)*(1/(rt[i+1,j]+rt[i,j]) + 1/(rt[i,j]+rt[i-1,j])) +                                   (1/dy**2)*(1/(rt[i,j+1]+rt[i,j]) + 1/(rt[i,j]+rt[i,j-1])))                        it = 0        while True:            pn = np.copy(p)            it += 1            for i in range(1,nx+1):                for j in range(1,ny+1):                    p[i,j] = (1-beta)*p[i,j] + beta*tmp2[i,j]*((1/dx**2*(p[i+1,j]/(rt[i+1,j]+rt[i,j])+p[i-1,j]/(rt[i,j]+rt[i-1,j])) +                                                          1/dy**2*(p[i,j+1]/(rt[i,j+1]+rt[i,j])+p[i,j-1]/(rt[i,j]+rt[i,j-1])) - tmp1[i,j]))            # #Periodic boundary condition for p:            # p[:,0]=p[:,ny]; p[:,ny+1]=p[:,1]            if it%100 == 0:                print(f'Pressure loop iterations: {it}')            if np.abs(pn-p).max() < maxError:                print(f'Pressure convergence achieved in {it} iterations.')                break            if it > maxit:                print(f'Pressure convergence not achieved. Max iterations reached in pressure loop.')                break                    #============ CORRECT THE VELOCITY ===============#        # u-velocity        # for i in range(1,nx):        #     for j in range(1,ny+1):        #         u[i,j] = ut[i,j] - dt*(2/dx)*(p[i+1,j]-p[i,j])/(r[i+1,j]+r[i,j])        # # v-velocity        # for i in range(1,nx+1):        #     for j in range(1, ny):        #         v[i,j] = vt[i,j] - dt*(2/dy)*(p[i,j+1]-p[i,j])/(r[i,j+1]+r[i,j])                        #Calculate u-velocity:        u[1:-1,1:-1]=ut[1:-1,1:-1]-dt*(2.0/dx)*(p[2:-1,1:-1]-p[1:-2,1:-1])/(r[2:-1,1:-1]+r[1:-2,1:-1])        #Calculate v-velocity:        v[1:-1,1:-1]=vt[1:-1,1:-1]-dt*(2.0/dy)*(p[1:-1,2:-1]-p[1:-1,1:-2])/(r[1:-1,2:-1]+r[1:-1,1:-2])                #============ ADVECT THE FRONT ===============#           # Bilinear interpolation for front velocity        uf = np.zeros(nf+2)        vf = np.zeros(nf+2)        for i in range(1,nf+1):            ip = int(np.floor(xf[i]/dx))            jp = int(np.floor(yf[i]/dy+0.5))            ax = xf[i]/dx-ip            ay = yf[i]/dy+0.5-jp            uf[i] = (1-ax)*(1-ay)*u[ip,jp] + ax*(1-ay)*u[ip+1,jp] + \                ay*(1-ax)*u[ip,jp+1] + ax*ay*u[ip+1,jp+1]                            ip = int(np.floor(xf[i]/dx+0.5))            jp = int(np.floor(yf[i]/dy))            ax = xf[i]/dx+0.5-ip            ay = yf[i]/dy-jp            vf[i] = (1-ax)*(1-ay)*v[ip,jp] + ax*(1-ay)*v[ip+1,jp] + \                ay*(1-ax)*v[ip,jp+1] + ax*ay*v[ip+1,jp+1]                        # Move the front        for i in range(1,nf+1):            xf[i] += dt*uf[i]            yf[i] += dt*vf[i]                xf[0] = xf[-2]        yf[0] = yf[-2]        xf[-1] = xf[1]        yf[-1] = yf[1]                # Distribute the density gradient        fx = np.zeros((nx+2,ny+2))        fy = np.zeros((nx+2, ny+2))        for i in range(1, nf+1):            nfx = -0.5*(yf[i+1]-yf[i-1])*(rho2-rho1)            nfy = 0.5*(xf[i+1]-xf[i-1])*(rho2-rho1)                        ip =int(np.floor(xf[i]/dx))            jp = int(np.floor(yf[i]/dy+0.5))            ax = xf[i]/dx - ip            ay = yf[i]/dy + 0.5 - jp            fx[ip,jp] += (1-ax)*(1-ay)*nfx/(dx*dy)            fx[ip+1,jp] += ax*(1-ay)*nfx/(dx*dy)            fx[ip,jp+1] += ay*(1-ax)*nfx/(dx*dy)            fx[ip+1,jp+1] += ax*ay*nfx/(dx*dy)                        ip =int(np.floor(xf[i]/dx + 0.5))            jp = int(np.floor(yf[i]/dy))            ax = xf[i]/dx + 0.5 - ip            ay = yf[i]/dy - jp            fy[ip,jp] += (1-ax)*(1-ay)*nfy/(dx*dy)            fy[ip+1,jp] += ax*(1-ay)*nfy/(dx*dy)            fy[ip,jp+1] += ay*(1-ax)*nfy/(dx*dy)            fy[ip+1,jp+1] += ax*ay*nfy/(dx*dy)                # Construct the density from the front        for it in range(maxit):            oldr = np.copy(r)            for i in range(1, nx+1):                for j in range(1, ny+1):                    r[i,j] = (1-beta)*r[i,j] + beta*0.25*(r[i+1,j]+r[i-1,j]+                              r[i,j+1]+r[i,j-1]+dx*fx[i-1,j]-dx*fx[i,j]+                              dy*fy[i,j-1]-dy*fy[i,j])            if np.max(np.abs(oldr-r)) < maxError:                break                    # Update the viscosity        m = np.ones((nx+2,ny+2))*m1        m[1:-1,1:-1] = m1 + (m2-m1)*(r[1:-1,1:-1]-rho1)/(rho2-rho1)                #------- END SECOND ORDER --------#    u = 0.5*(u+un)    v = 0.5*(v+vn)    m = 0.5*(m+mn)    r = 0.5*(r+rn)    xf = 0.5*(xf+xfn)    yf = 0.5*(yf+yfn)        #============ ADD POINTS TO THE FRONT ===============#     xfold = np.copy(xf)    yfold = np.copy(yf)    j = 0    for i in range(1, nf+1):        ds = np.sqrt(((xfold[i]-xf[j])/dx)**2 + ((yfold[i]-yf[j])/dy)**2)        if ds > 0.5:            j+=1            if j > nf:                oldsize = xf.size                xf = np.resize(xf, oldsize+1)                yf = np.resize(yf, oldsize+1)            xf[j] = 0.5*(xfold[i]+xf[j-1])            yf[j] = 0.5*(yfold[i]+yf[j-1])            j+=1            if j > nf:                oldsize = xf.size                xf = np.resize(xf, oldsize+1)                yf = np.resize(yf, oldsize+1)            xf[j] = xfold[i]            xf[j] = xfold[i]        elif ds < 0.25:            pass        else:            j+=1            if j > nf:                oldsize = xf.size                xf = np.resize(xf, oldsize+1)                yf = np.resize(yf, oldsize+1)            xf[j] = xfold[i]            yf[j] = yfold[i]                xf = np.resize(xf,j+2)    yf = np.resize(yf,j+2)    uf = np.resize(uf,j+2)    vf = np.resize(vf,j+2)    tx = np.resize(tx,j+2)    ty = np.resize(ty,j+2)    nf = j    xf[0] = xf[-2]    yf[0] = yf[-2]    xf[-1] = xf[1]    yf[-1] = yf[1]        uu = 0.5*(u[0:nx,1:ny+1] + u[0:nx,0:ny])    vv = 0.5*(v[1:nx+1,0:ny] + v[0:nx,0:ny])    yy, xx = np.mgrid[0:(nx-1)*dx:nx*1j, 0:(ny-1)*dy:ny*1j]    X, Y = np.meshgrid(x, y)    plt.clf()    plt.contourf(x,y,r.T,5, cmap=cm.jet)    plt.colorbar()    plt.quiver(xx,yy,uu.T,vv.T)    plt.plot(xf[0:nf+1], yf[0:nf+1],linewidth=5.0)    plt.xlabel('x')    plt.ylabel('y')    plt.pause(0.05)    display.clear_output(wait=True)    display.display(plt.gcf())    print(f'Step {step}')plt.show()                                        